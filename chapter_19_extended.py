# 1. Каким образом связаны друг с другом выражения lambda и операторы def?
ans1 = 'это выражение и оператор создания функций, lambda - возвращает объект функции, ' \
       'def - присваивает функцию имени'
# 2. Какой смысл применять lambda?
ans2 = 'удобочитаемость кода + использование в map, filter и тд'
# 3. Сравните и противопоставьте map, filter и reduce.
ans3 = 'map, filter: возвращает итератор, reduce (из модуля functools): одиночный объект'
# 4. Что такое аннотации функций и как их использовать?
ans4 = 'описание аргументов и результата функции, собираются в словарь,' \
       'присваиваемый атрибуту __annotations__ функции'
# 5. Что такое рекурсивные функции и как их применять?
ans5 = 'функции, которые вызывают сами себя прямо или косвенно,' \
       'можно заменить стеками или очередями'
# 6. Назовите несколько универсальных принципов проектирования функций.
ans6 = 'небольшими, самодостаточными, иметь единственное назначение ' \
       'и взаимодействовать с др. компонентами через входные аргуенты и возвращаемые значения. ' \
       'могут применять изменяемые аргументы, если изменения ожидаемы, ' \
       'а некоторые типы программ заключают в себе др. механизмы передачи данных'
# 7. Назовите три или больше способов передачи результатов функций вызывающему коду.
ans7 = 'установка глобальных переменных, return, ' \
       'изменение передаваемых аргументов + файлы и сокеты'


def sumtree1(L):
    tot = 0
    items = L.copy()
    while items:
        front = items.pop(0)
        if not isinstance(front, list):
            tot += front
        else:
            items.extend(front)
    return tot


lst = [1, [2, [6, 7, [8, 9]]], [100, 6]]
print(sumtree1(lst))

vid = {'3060ti': 38070.08, '3070': 47609.28, '3070ti': 56281.28, '3080': 65820.48,
       '3080ti': 110047.68, '3090': 143001.28}
var1 = {'3060ti': 70817, 'Intel Core i5-12400F': 17699, 'ID-COOLING SE-214V3': 1550}
budget = dict(CPU=24000, motherboard=12000, case=6000, cooler=2500, RAM=15000, SSD=12000,
              BP=10000, monitor=27000, mousekeyboard=4000)
cost = sum(list(budget.values()))


def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        value = next(it)
    else:
        value = initializer
    for element in it:
        value = function(value, element)
    return value


y = reduce(lambda x, y: x+y, list(range(100)))

