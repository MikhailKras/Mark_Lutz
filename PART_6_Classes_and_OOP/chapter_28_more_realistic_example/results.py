# 1. Когда мы извлекаем объект Manager из хранилища shelve и выводим его, то откуда поступает логика форматирования отображения?
ans1 = 'AttrDisplay'

# 2. Когда мы извлекаем объект Person из хранилища shelve, не импортируя его модуль, то каким образом объект узнает,
# что он имеет метод give_raise, который мы можем вызвать?
ans2 = 'shelve автоматически повторно связывает экземпляр с классом, из которого он был создан'

# 3. Почему настолько важно перемещать обработку внутрь методов вместо ее жесткого кодирования за пределами класса?
ans3 = 'Для того, чтобы в будущем приходилось изменять только 1 раз. Инкапсуляция - помещение логики в оболочку интерфейсов'

# 4. Почему лучше настраивать за счет создания подклассов, а не копировать исходный код и модифицировать копию?
ans4 = 'Сокращает объем работы'

# 5. Почему для выполнения стандартных действий лучше вызывать метод суперкласса, а не копировать и модифицировать их код в подклассе?
ans5 = 'Чтобы не удваивать работу'

# 6. Почему лучше применять инструменты вроде __dict__, которые позволяют обрабатывать объекты обобщенно,
# чем писать дополнительный специализированный код для каждой разновидности класса?
ans6 = 'Сокращение работы'

# 7. Опишите в общих чертах, когда вы могли бы выбрать использование внедрения и композиции объектов вместо наследования?
ans7 = 'Композиция - где множество объектов агрегируются в единое целое и управляются классом уровня контроллера'

# 8. Что бы вы изменили, если бы объекты, реализованные в настоящей главе, применяли словарь для имен и список
# для названий должностей, как в похожих примерах, приводимых ранее в книге?
ans8 = 'last_name - изменить, __init__ в Person'

# 9. Как бы вы модифицировали классы в этой главе для реализации базы данных личных контактов в Python?
ans9 = 'attrs: name, address, birthday, phone, email'